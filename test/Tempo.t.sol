// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.30;

import {Test, console} from "forge-std/Test.sol";
import {Escrow, IERC20} from "../src/Escrow.sol";
import {ReceiptValidator} from "../src/ReceiptValidator.sol";

contract ReceiptValidatorWrapper {
    function validateTransferInReceipt(
        bytes calldata receiptRlp,
        uint256 logIndex,
        address tokenContract,
        address toAddress,
        uint256 expectedAmount
    ) external pure returns (bool) {
        return ReceiptValidator.validateTransferInReceipt(receiptRlp, logIndex, tokenContract, toAddress, expectedAmount);
    }
}

/**
 * @title TempoTest
 * @dev Tests for Tempo (0x76) transaction proof verification
 *
 * TX: 0x9714f04aaa75e283b4fd23da05742d9f0d1bca8feefd2e2e94dbd4b99ab8ba6e
 * Block: 5057985 on Tempo testnet (chainId 42429)
 */
contract TempoTest is Test {
    ReceiptValidatorWrapper validator;

    // Block header RLP (Tempo block 5057985)
    bytes constant BLOCK_HEADER =
        hex"f90276840d693a408402faf080820235f90266a0ace84c9172eb2daf2d3247def3ab2176df3a845e50799299bf57f2198342c1d8a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a07c598b42aa5725d46281fa7a992c5e38a1225f69c7fc0a1f4772e2e0ccd6d489a0854fa1c14c062275941d0dc7e0b1c7c9366987a45c714bcf8ebcd00632e90385a0cd7273918129ab99e027d725890a2346fe3d14a6761b0b175130b2f3f424440db901008000000000020002008000080000049100000050210400050100000008021101410064000001000880c0180051000000000180200088900120808000200040082a41240810204100000008080000040020088001000000000000000c04082200c2000022024100004a60201004100804001040028800c84004803114125406181001004044820000000900900222028c100304009812402408400010002500080009a0440000401102000089a0140b0002320044440000028c52410600580400c00000020018010082100004800000020000146000a041000000026100003280100010c00021088000011000100a02000100020000800000005004110001243080834d2dc1841dcd65008332a31f84693c3ea980a000000000000000000000000000000000000000000000000000000000000000008800000000000000008502540be400a056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b4218080a00000000000000000000000000000000000000000000000000000000000000000a0e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";

    // Receipt RLP (Tempo type 0x76)
    bytes constant RECEIPT_RLP =
        hex"76f90245018301881db9010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000008000000000008800000000000000000000400000000000000000000000000000000000000000000000000000000000010000000000000000000000000000800000020000000000000100040000040000000000000000020000000000000000000000000000000000000000002000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000f9013af89b9420c0000000000000000000000000000000000001f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000007d8896fd8b30be58fd841f78e170b7626f04e391a0000000000000000000000000123453b4ce4b4bb18eaec84c69eb745c83fc1b2fa00000000000000000000000000000000000000000000000000000000005f5e100f89b9420c0000000000000000000000000000000000001f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000007d8896fd8b30be58fd841f78e170b7626f04e391a0000000000000000000000000feec000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000022b";

    // MPT Proof nodes
    bytes constant PROOF_NODES =
        hex"f9051fb8d3f8d1a076f4808a5fabfe8a6281c58fc20d703d849a1e9a8d2b183cf1a8bb3d07150a85a0b15a6d6528c538b6070137dc7cbad1f73fe79fd8805e8751b128511a13e8f71aa029a5e990f8dc0031122350ce0500bfeb0fe59918db06ab5759df57e8d5a8c65ba0b5f33e9a65313eb867593be4f3db09329fe14e7bb722ab1a4650a169a8eab20ca0286ba38099a84a6620d06855cf8b675c4798f7179aba677659a1b17d4f3467bb808080a0164f50181f1ae23bd5f9e86fa0fb5eda6f9c63f4a4376c8036cd580940e287048080808080808080b901f4f901f180a0d06b31aa8b38947f86dbeaf13479e3e5ce10dbda679715014ff6ea29f645adb1a0ab5bd9bd849009519bba95f5fa0072097197dbb43dab075e20c70b4b489a785ea085c647e255ac3912dce92b08e73b9ddc36bd764e9a4813f1817f8a8afbd88df1a0b4dca0e262b18f78957b26f89ebf908e34ee9ced7e9b19d24fa7262796a4acdba06eed6e7c3aa4e6c26ec88766434eb2464ec0793c79ebd12c497a4123bd033ae2a0b676e1ab320051c14902c72af4c5f7bf1c50fb3a8a4d77be4ea4d6793a668090a09aca5ec44623288e8a171a0f3abd2af923faf3fa5e3876af4070b415e068648ea09c65bc54b5f48b2d69ba211db2e9cbdece1bba8ce13374fc765286f1f461b686a0dc7f852ddb3d4ababd6dd0318fed75791746bfd5298459886ee3e8a670926d27a05db33c589b56c94e561e4afb3ea711b047f1e59e9eb1745aa25362457eb15b6ca0a0271c006a67920152d1adafe55eea4e2b978bee092c66ce86aef87bf6a2a742a06b0a6eb03ff56dd5caf4ff08e7fb7f89c75a855fb1dbeb0a3fbe66fc854e27eea042fa7c220681a9a96ea53a57743c6ae8b004e3bab660c7b2ad0042bd6d0a2c8fa039a533dcfafa4f0cef373ef8f38d62a26a0e6f6d56c0ba3e41e17413d1df9d54a002f188e47c21ff8dd8141382e028998bb6929808855cb23cc3fab6141e6b33b180b90250f9024d20b9024976f90245018301881db9010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000008000000000008800000000000000000000400000000000000000000000000000000000000000000000000000000000010000000000000000000000000000800000020000000000000100040000040000000000000000020000000000000000000000000000000000000000002000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000f9013af89b9420c0000000000000000000000000000000000001f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000007d8896fd8b30be58fd841f78e170b7626f04e391a0000000000000000000000000123453b4ce4b4bb18eaec84c69eb745c83fc1b2fa00000000000000000000000000000000000000000000000000000000005f5e100f89b9420c0000000000000000000000000000000000001f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000007d8896fd8b30be58fd841f78e170b7626f04e391a0000000000000000000000000feec000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000022b";

    bytes constant RECEIPT_PATH = hex"01";

    // Block constants
    uint256 constant BLOCK_NUMBER = 5057985;
    bytes32 constant BLOCK_HASH = 0x2f47597aaeca5e9ebbe84c39a1d467bbcfde88b12a3d0ab5808de2200f4ab106;

    // Transfer event data
    address constant TOKEN = 0x20C0000000000000000000000000000000000001;
    address constant FROM_ADDRESS = 0x7d8896fd8b30Be58fd841f78e170B7626f04E391;
    address constant TO_ADDRESS = 0x123453b4cE4B4bB18EAEc84C69eb745C83fC1b2F;
    uint256 constant AMOUNT = 100000000;

    // Fee payment (second log)
    address constant FEE_RECIPIENT = 0xfeEC000000000000000000000000000000000000;
    uint256 constant FEE_AMOUNT = 555;

    function setUp() public {
        vm.chainId(42429);
        validator = new ReceiptValidatorWrapper();
    }

    function testBlockHeaderHash() public pure {
        assertEq(keccak256(BLOCK_HEADER), BLOCK_HASH);
    }

    function testReceiptTypePrefix() public pure {
        assertEq(uint8(RECEIPT_RLP[0]), 0x76);
    }

    function testValidateTransfer() public view {
        assertTrue(validator.validateTransferInReceipt(RECEIPT_RLP, 0, TOKEN, TO_ADDRESS, AMOUNT));
    }

    function testValidateFeeTransfer() public view {
        assertTrue(validator.validateTransferInReceipt(RECEIPT_RLP, 1, TOKEN, FEE_RECIPIENT, FEE_AMOUNT));
    }

    function testRejectWrongAmount() public {
        vm.expectRevert("Transfer amount mismatch");
        validator.validateTransferInReceipt(RECEIPT_RLP, 0, TOKEN, TO_ADDRESS, AMOUNT + 1);
    }

    function testRejectWrongRecipient() public {
        vm.expectRevert("To address mismatch");
        validator.validateTransferInReceipt(RECEIPT_RLP, 0, TOKEN, address(0xdead), AMOUNT);
    }

    function testRejectWrongToken() public {
        vm.expectRevert("Wrong token contract");
        validator.validateTransferInReceipt(RECEIPT_RLP, 0, address(0xbeef), TO_ADDRESS, AMOUNT);
    }

    function testEndToEndProof() public {
        address deployer = makeAddr("deployer");

        vm.mockCall(TOKEN, abi.encodeWithSelector(IERC20.transferFrom.selector), abi.encode(true));
        vm.mockCall(TOKEN, abi.encodeWithSelector(IERC20.transfer.selector), abi.encode(true));
        vm.mockCall(TOKEN, abi.encodeWithSelector(IERC20.send.selector), abi.encode(true));

        vm.prank(deployer);
        Escrow escrow = new Escrow(TOKEN, TO_ADDRESS, AMOUNT, 500e18, 500e18);

        vm.prank(FROM_ADDRESS);
        escrow.bond(250e18);

        vm.roll(BLOCK_NUMBER + 10);
        vm.setBlockhash(BLOCK_NUMBER, BLOCK_HASH);

        vm.prank(FROM_ADDRESS);
        escrow.collect(
            Escrow.ReceiptProof({
                blockHeader: BLOCK_HEADER,
                receiptRlp: RECEIPT_RLP,
                proofNodes: PROOF_NODES,
                receiptPath: RECEIPT_PATH,
                logIndex: 0
            }),
            BLOCK_NUMBER
        );
    }
}
